; docformat = 'rst'

;+
; Report an error with the previous SQL command to the log.
;
; :Keywords:
;   sql_statement : in, required, type=string
;     previous SQL command
;   status : in, required, type=integer
;     status of previous statement, if `status` is not 0, then the statment
;     will be logged
;   error_message : in, required, type=string
;     error message associated with previous statement, will be empty if
;     `status` is 0
;-
pro ucompdbmysql::report_error, sql_statement=sql_cmd, $
                                status=status, $
                                error_message=error_message
  compile_opt strictarr

  if (status ne 0L) then begin
    mg_log, 'error with SQL statement', name=self.logger_name, /error
    mg_log, 'status: %d', status, name=self.logger_name, /error
    mg_log, '%s', error_message, name=self.logger_name, /error
    mg_log, 'SQL command: %s', sql_cmd, name=self.logger_name, /error
  endif
end


;+
; Report any warnings generated by the previous SQL command  to the log.
;
; :Keywords:
;   sql_statement : in, required, type=string
;     previous SQL command
;   n_warnings : in, required, type=integer
;     number of warnings generated by the previous SQL command
;-
pro ucompdbmysql::report_warnings, sql_statement=sql_cmd, n_warnings=n_warnings
  compile_opt strictarr

  if (n_warnings gt 0L) then begin
    mg_log, '%d warnings for SQL statement', n_warnings, $
            name=self.logger_name, /error
    mg_log, 'SQL command: %s', sql_cmd, name=self.logger_name, /error
    warnings = self->query('show warnings', status=status)
    if (status ne 0L) then begin
      mg_log, 'error retrieving warnings', name=self.logger_name, /error
    endif

    for w = 0L, n_warnings - 1L do begin
      mg_log, '%s [%d]: %s', $
              warnings[w].level, warnings[w].code, warnings[w].message, $
              name=self.logger_name, /error
    endfor
  endif
end


;+
; Report the previous SQL command.
;
; :Params:
;   mysql_statement : in, required, type=string
;     previous SQL command
;-
pro ucompdbmysql::report_statement, mysql_statement
  compile_opt strictarr

  if (self.log_statements) then begin
    mg_log, mysql_statement, name=self.logger_name, /debug
  endif
end


;+
; Set properties.
;-
pro ucompdbmysql::setProperty, _extra=e
  compile_opt strictarr

  if (n_elements(e) gt 0L) then self->mgdbmysql::setProperty, _extra=e
end


;+
; Get properties.
;-
pro ucompdbmysql::getProperty, _ref_extra=e
  compile_opt strictarr

  if (n_elements(e) gt 0) then self->mgdbmysql::getProperty, _strict_extra=e
end


;+
; Cleanup resources.
;-
pro ucompdbmysql::cleanup
  compile_opt strictarr

  self->mgdbmysql::cleanup
end


;+
; Create a connection to the UCoMP database.
;
; :Returns:
;   1 if successfully initialized, 0 if not
;
; :Keywords:
;   logger_name : in, optional, type=string
;     name of logger to log messages to
;   log_statements : in, optional, type=boolean
;     set to log each SQL command, not just warnings and errors
;   _extra : in, optional, type=keywords
;     keywords to `MGdbMySQL::init`
;-
function ucompdbmysql::init, logger_name=logger_name, $
                             log_statements=log_statements, $
                             _extra=e
  compile_opt strictarr

  status = self->mgdbmysql::init(_extra=e)
  if (status ne 1) then return, status

  self.log_statements = keyword_set(log_statements)
  if (n_elements(logger_name) gt 0L) then self.logger_name = logger_name

  return, 1
end


;+
; Define instance variables.
;-
pro ucompdbmysql__define
  compile_opt strictarr

  !null = { UCoMPdbMySQL, inherits MGdbMySQL, $
            logger_name: '', $
            log_statements: 0B }
end
