; docformat = 'rst'

;= handle darks

;+
; Cache the master dark file.
;
; :Params:
;   filename : in, optional, type=string
;     filename of master dark file, if not present, then `darks`, `times`,
;     `exptimes`, `gain_modes` and `raw_files` must be present
;
; :Keywords:
;   darks : in, optional, type="fltarr(..., n)"
;     dark images
;   times : in, optional, type=fltarr(n)
;     times of the darks [hours into observing day]
;   exptimes : in, optional, type=fltarr(n)
;     exposure times of the darks [ms]
;   gain_modes : in, optional, type=bytarr(n)
;     gain modes of the darks [ms]
;   raw_files : in, optional, type=strarr(n)
;     raw filenames corresponding to the dark images
;-
pro ucomp_calibration::cache_darks, filename, $
                                    darks=darks, $
                                    times=times, $
                                    exptimes=exptimes, $
                                    gain_modes=gain_modes, $
                                    raw_files=raw_files
  compile_opt strictarr

  self.run->getProperty, logger_name=logger_name

  ; master dark file with extensions 1..n:
  ;   exts 1 to n - 3:   dark images
  ;   ext n - 2:         times of the dark images
  ;   ext n - 1:         exposure times of the dark images
  ;   ext n:             gain modes of the dark images

  if (n_elements(filename) gt 0L) then begin
    fits_open, filename, fcb

    ; read the first extension to determine the dark size and cache it
    fits_read, fcb, dark_image, dark_header, exten_no=1

    dims = size(dark_image, /dimensions)
    dark_size = n_elements(dark_image)

    darks = make_array(dimension=[dims, fcb.nextend - 3L], $
                       type=size(dark_image, /type))
    raw_files = strarr(fcb.nextend - 3L)

    darks[0] = dark_image
    raw_files[0] = ucomp_getpar(dark_header, 'RAWFILE')

    ; read the rest of the dark images
    for e = 2L, fcb.nextend - 3L do begin   ; there are 3 "index" extensions at end of file
      fits_read, fcb, dark_image, dark_header, exten_no=e
      raw_files[e - 1L] = ucomp_getpar(dark_header, 'RAWFILE')
      darks[(e - 1) * dark_size] = dark_image
    endfor

    ; read the times and exposure times
    fits_read, fcb, times, times_header, exten_no=fcb.nextend - 2L
    fits_read, fcb, exptimes, exptimes_header, exten_no=fcb.nextend - 1L
    fits_read, fcb, gain_modes, gain_modes_header, exten_no=fcb.nextend

    fits_close, fcb
  endif

  *self.darks = darks
  *self.dark_times = times
  *self.dark_exptimes = exptimes
  *self.dark_gain_modes = gain_modes
  *self.dark_raw_files = raw_files

  mg_log, '%d darks cached', n_elements(times), name=logger_name, /info
end


;+
; Discard the dark cache.
;-
pro ucomp_calibration::discard_darks
  compile_opt strictarr

  *self.darks = !null
  *self.dark_times = !null
  *self.dark_exptimes = !null
  *self.dark_mode_gains = !null
  *self.dark_raw_files = !null
end


;+
; Retrieve a dark image for a given science image.
;
; :Returns:
;   interpolated by time dark image, `fltarr(nx, ny, nc)`
;
; :Params:
;   obsday_hours : in, required, type=float
;     time of science image in hours into the observing day
;   exptime : in, required, type=float
;     exposure time [ms] needed
;   gain_mode : in, required, type=string
;     gain mode of required dark, i.e., "high" or "low"
;
; :Keywords:
;   found : out, optional, type=boolean
;     set to a named variable to retrieve whether a suitable dark was found
;   error_msg : out, optional, type=string
;     set to a named variable to retrieve any error message generated by the
;     call; set to empty string if no error occurred
;   master_extensions : out, optional, type=long/lonarr(2)
;     set to a named variable to retrieve the extension(s) in the master dark
;     file used to create the returned dark
;   raw_filenames : out, optional, type=string/strarr(2)
;     set to a named variable to retrieve the raw filenames of the darks used to
;     create the returned dark
;   coefficients : out, optional, type=float/fltarr(2)
;     set to a named variable to retrieve the coefficient(s) determining the
;     linear combination of the two darks used to create the given dark; 1.0
;     if only one dark was used
;-
function ucomp_calibration::get_dark, obsday_hours, exptime, gain_mode, $
                                      found=found, $
                                      error_msg=error_msg, $
                                      master_extensions=master_extensions, $
                                      raw_filenames=raw_filenames, $
                                      coefficients=coefficients
  compile_opt strictarr

  interpolate = self.run->config('calibration/interpolate_darks')

  found = 0B
  error_msg = ''
  if (n_elements(*self.darks) eq 0L) then begin
    error_msg = 'no darks'
    return, !null
  endif

  ; find the darks with an exposure time that is close enough to the given
  ; exptime
  exptime_threshold = 0.01   ; [ms]
  gain_index        = gain_mode eq 'high'
  valid_indices = where(abs(exptime - *self.dark_exptimes) lt exptime_threshold $
                          and (*self.dark_gain_modes eq gain_index), $
                        n_valid_darks)
  if (n_valid_darks eq 0L) then begin
    n_valid_exptime_darks = total(abs(exptime - *self.dark_exptimes) lt exptime_threshold, $
                                  /integer)
    n_valid_mode_darks = total(*self.dark_gain_modes eq gain_index, /integer)

    error_msg = string(n_valid_exptime_darks, n_valid_mode_darks, $
                       format='%d valid EXPTIME darks, %d valid mode darks')
    return, !null
  endif

  found = 1B

  ; find closest two darks (or closest dark if before first dark or after last
  ; dark)
  valid_darks = (*self.darks)[*, *, *, valid_indices]
  valid_times = (*self.dark_times)[valid_indices]
  if (obsday_hours lt valid_times[0]) then begin               ; before first dark
    interpolated_dark = float(valid_darks[*, *, *, 0])

    master_extensions = valid_indices[0] + 1L
    raw_filenames = strtrim((*self.dark_raw_files)[valid_indices[0]], 2)
    coefficients = 1.0
  endif else if (obsday_hours gt valid_times[n_valid_darks - 1]) then begin   ; after last dark
    interpolated_dark = float(valid_darks[*, *, *, n_valid_darks - 1])

    master_extensions = valid_indices[n_valid_darks - 1] + 1L
    raw_filenames = strtrim((*self.dark_raw_files)[valid_indices[n_valid_darks - 1]], 2)
    coefficients = 1.0
  endif else begin                                     ; between darks
    if (keyword_set(interpolate)) then begin
      index1 = value_locate(valid_times, obsday_hours)
      index2 = index1 + 1L

      dark1 = valid_darks[*, *, *, index1]
      dark2 = valid_darks[*, *, *, index2]
      ; mg_log, 'dark mean by camera [1]: %0.3f, %0.3f', $
      ;         mean(mean(dark1, dimension=1), dimension=1), $
      ;         name=self.run.logger_name, /debug
      ; mg_log, 'dark mean by camera [2]: %0.3f, %0.3f', $
      ;         mean(mean(dark2, dimension=1), dimension=1), $
      ;         name=self.run.logger_name, /debug

      a1 = (valid_times[index2] - obsday_hours) / (valid_times[index2] - valid_times[index1])
      a2 = (obsday_hours - valid_times[index1]) / (valid_times[index2] - valid_times[index1])
      interpolated_dark = a1 * dark1 + a2 * dark2

      master_extensions = [index1, index2] + 1L
      raw_filenames = strtrim((*self.dark_raw_files)[[index1, index2]], 2)

      coefficients = [a1, a2]
    endif else begin
      indices = [0L, 1L] + value_locate(valid_times, obsday_hours)

      !null = min(abs(valid_times[indices] - obsday_hours), index)

      interpolated_dark = valid_darks[*, *, *, indices[index]]

      master_extensions = indices[index] + 1L
      raw_filenames = strtrim((*self.dark_raw_files)[indices[index]], 2)

      coefficients = 1.0
    endelse
  endelse

  ; mg_log, 'dark mean by camera: %0.3f, %0.3f', $
  ;         mean(mean(interpolated_dark, dimension=1), dimension=1), $
  ;         name=self.run.logger_name, /debug
  return, interpolated_dark
end


;= handle flats

;+
; Cache the master flat files.
;
; :Params:
;   filenames : in, optional, type=strarr
;     filename of master flat files, if not present, then `flats`, `times`,
;     `exptimes`, `wavelengths`, `gain_modes`, `onbands`, `raw_files`, and
;     `extensions`  must be present
;
; :Keywords:
;   flats : in, optional, type="fltarr(nx, ny, n_pol_states, n_cameras, n)"
;     flat images
;   times : in, optional, type=fltarr(n)
;     times of the darks [hours into observing day]
;   exptimes : in, optional, type=fltarr(n)
;     exposure times of the darks [ms]
;   wavelengths : in, optional, type=fltarr(n)
;     wavelengths of the darks [nm]
;   gain_modes : in, optional, type=bytarr(n)
;     gain modes of the darks [ms]
;   onbands : in, optional, type=lonarr(n)
;     `ONBAND` indices of the darks
;   raw_files : in, optional, type=strarr(n)
;     raw filenames of the darks
;   extensions : in, optional, type=strarr(n)
;     extensions in the raw files used
;-
pro ucomp_calibration::cache_flats, filenames, $
                                    flats=flats, $
                                    times=times, $
                                    exptimes=exptimes, $
                                    wavelengths=wavelengths, $
                                    gain_modes=gain_modes, $
                                    onbands=onbands, $
                                    sgsdimv=sgsdimv, $
                                    raw_files=raw_files, $
                                    extensions=extensions
  compile_opt strictarr

  self.run->getProperty, logger_name=logger_name

  ; master flat file with extensions 1..n:
  ;   exts 1 to n - 5:   flat images
  ;   ext n - 4:         times of the flat images
  ;   ext n - 3:         exposure times of the flat images
  ;   ext n - 2:         wavelengths of the flat images
  ;   ext n - 1:         gain modes of the flat images
  ;   ext n:             onbands of the flat images
  n_index_exts = 5L

  if (n_elements(filenames) gt 0L) then begin
    ; determine total number of flats in all flat files
    n_flats_per_file = lonarr(n_elements(filenames))
    for f = 0L, n_elements(filenames) - 1L do begin
      fits_open, filenames[f], fcb
      n_flats_per_file[f] = fcb.nextend - n_index_exts  ; not including the index extensions
      fits_close, fcb
    endfor
    n_flats = total(n_flats_per_file, /integer)

    n_cameras   = 2L
    flats       = fltarr(nx, ny, n_cameras, n_flats)
    times       = fltarr(n_flats)
    exptimes    = fltarr(n_flats)
    wavelengths = fltarr(n_flats)
    gain_modes  = lonarr(n_flats)
    onbands     = lonarr(n_flats)
    sgsdimv     = fltarr(n_flats)
    extensions  = strarr(n_flats)
    raw_files   = strarr(n_flats)

    i = 0L
    for f = 0L, n_elements(filenames) - 1L do begin
      fits_open, filenames[f], fcb

      for e = 1L, fcb.nextend - n_index_exts do begin   ; not including the index extensions
        fits_read, fcb, flat_image, flat_header, exten_no=e
        flats[0, 0, 0, i + e - 1L] = flat_image
        raw_files[e - 1L] = ucomp_getpar(flat_header, 'RAWFILE')
        extensions[e - 1L] = ucomp_getpar(flat_header, 'RAWEXT')
        sgsdimv[e - 1L] = ucomp_getpar(flat_header, 'SGSDIMV')
      endfor

      ; read index extensions
      fits_read, fcb, flat_times, times_header, exten_no=fcb.nextend - 4L
      fits_read, fcb, flat_exptimes, exptimes_header, exten_no=fcb.nextend - 3L
      fits_read, fcb, flat_wavelengths, wavelengths_header, exten_no=fcb.nextend - 2L
      fits_read, fcb, flat_gain_modes, gain_modes_header, exten_no=fcb.nextend - 1L
      fits_read, fcb, flat_onbands, onbands_header, exten_no=fcb.nextend

      times[i]       = flat_times
      exptimes[i]    = flat_exptimes
      wavelengths[i] = flat_wavelengths
      gain_modes[i]  = flat_gain_modes
      onbands[i]     = flat_onbands

      i += n_elements(flat_times)

      fits_close, fcb
    endfor
  endif

  ; concatenate over the last (5th, i.e., index 4) dimension if flats are
  ; already present
  if (n_elements(*self.flats) eq 0L) then begin
    *self.flats = flats
    *self.flat_times = times
    *self.flat_exptimes = exptimes
    *self.flat_wavelengths = wavelengths
    *self.flat_gain_modes = gain_modes
    *self.flat_onbands = onbands
    *self.flat_sgsdimv = sgsdimv
    *self.flat_extensions = extensions
    *self.flat_raw_files = raw_files
    if (n_elements(n_flats_per_file) eq 0L) then begin
      *self.flat_wave_region_offsets = [*self.flat_wave_region_offsets, n_elements(times)]
    endif else begin
      *self.flat_wave_region_offsets = [*self.flat_wave_region_offsets, n_flats_per_file]
    endelse
  endif else begin
    dims = size(*self.flats, /dimensions)
    n_existing_flats = n_elements(*self.flat_times)
    n_appending_flats = n_elements(times)

    new_dims = [dims[0:2], n_existing_flats + n_appending_flats]
    mg_log, 'caching flats dimensions [%s]', strjoin(strtrim(new_dims, 2), ', '), $
            name=logger_name, /debug
    new_flats = make_array(new_dims, type=size(flats, /type))
    new_flats[0, 0, 0, 0] = *self.flats
    new_flats[0, 0, 0, n_existing_flats] = flats

    *self.flats = new_flats
    *self.flat_times = [*self.flat_times, times]
    *self.flat_exptimes = [*self.flat_exptimes, exptimes]
    *self.flat_wavelengths = [*self.flat_wavelengths, wavelengths]
    *self.flat_gain_modes = [*self.flat_gain_modes, gain_modes]
    *self.flat_onbands = [*self.flat_onbands, onbands]
    *self.flat_sgsdimv = [*self.flat_sgsdimv, sgsdimv]
    *self.flat_extensions = [*self.flat_extensions, extensions]
    *self.flat_raw_files = [*self.flat_raw_files, raw_files]
    *self.flat_wave_region_offsets = [*self.flat_wave_region_offsets, n_elements(times)]
  endelse

  ; debug = 1B
  ; if (debug) then begin
  ;   mg_log, 'offsets: %s', strjoin(strtrim(*self.flat_wave_region_offsets, 2), ','), name=logger_name, /debug
  ;   offsets = total(*self.flat_wave_region_offsets, /cumulative, /preserve_type)
  ;   offset = n_elements(offsets) gt 1 ? offsets[-2] : 0L
  ;   mg_log, 'offset: %d', offset, name=logger_name, /debug
  ;   for f = offset, n_elements(*self.flat_times) - 1L do begin
  ;     mg_log, '[index: %d] %0.2f, %0.3f ms, %0.3f nm, %d, %d, %s, %s', $
  ;             f, $
  ;             (*self.flat_times)[f], $
  ;             (*self.flat_exptimes)[f], $
  ;             (*self.flat_wavelengths)[f], $
  ;             (*self.flat_gain_modes)[f], $
  ;             (*self.flat_onbands)[f], $
  ;             (*self.flat_extensions)[f], $
  ;             (*self.flat_raw_files)[f], $
  ;             name=logger_name, /debug
  ;   endfor
  ; endif

  mg_log, '%d flats cached', n_elements(times), name=logger_name, /info
  mg_log, '%d total flats cached', n_elements(*self.flat_times), name=logger_name, /info
end


;+
; Convert global index into flats cache to an index into the wave region based
; index.
;
; :Returns:
;   long
;
; :Params:
;   indices : in, required, type=long/lonarr
;     index, or indices, into the global flat cache
;-
function ucomp_calibration::convert_flat_index_to_wave_region, indices
  compile_opt strictarr

  region_markers = total(*self.flat_wave_region_offsets, /cumulative, /preserve_type)
  region_marker_index = value_locate(region_markers, indices)
  wave_region_indices = indices - region_markers[region_marker_index]
  return, wave_region_indices
end

;+
; Discard the flat cache.
;-
pro ucomp_calibration::discard_flats
  compile_opt strictarr

  *self.flats = !null
  *self.flat_times = !null
  *self.flat_exptimes = !null
  *self.flat_wavelengths = !null
  *self.flat_gain_modes = !null
  *self.flat_extensions = !null
  *self.flat_raw_files = !null
end


;+
; Retrieve a dark corrected flat image for a given science image. The exposure
; time of the found flat will be normalized to the required exposure time given
; by `exptime`. Other attributes such as `gain_mode`, `onband`, and
; `wavelength` will be matched exactly.
;
; :Returns:
;   flat image, `fltarr(nx, ny, np, nc)`
;
; :Params:
;   obsday_hours : in, required, type=float
;     time of science image in hours into the observing day
;   exptime : in, required, type=float
;     exposure time [ms] needed
;   gain_mode : in, required, type=string
;     gain mode of required dark, i.e., "high" or "low"
;   onband : in, required, type=string
;     `ONBAND` value, i.e., "rcam" or "tcam"
;   wavelength : in, required, type=float
;     wavelength of science image in nm
;
; :Keywords:
;   found : out, optional, type=boolean
;     set to a named variable to retrieve whether a suitable dark was found
;   error_msg : out, optional, type=string
;     set to a named variable to retrieve any error message generated by the
;     call; set to empty string if no error occurred
;   times_found : out, optional, type=float
;     set to a named variable to retrieve the time (in hours into the observing
;     day) of the found flat
;   master_extensions : out, optional, type=long/lonarr(2)
;     set to a named variable to retrieve the extension(s) in the master flat
;     file used to create the returned flat
;   raw_extensions : out, optional, type=long/lonarr(2)
;     set to a named variable to retrieve the extensions within the raw files
;     used to create the returned flat
;   raw_filenames : out, optional, type=string/strarr(2)
;     set to a named variable to retrieve the raw filenames of the flats used to
;     create the returned flat
;   coefficients : out, optional, type=float/fltarr(2)
;     set to a named variable to retrieve the coefficient(s) determining the
;     linear combination of the two flats used to create the given flat; 1.0
;     if only one flat was used
;-
function ucomp_calibration::get_flat, obsday_hours, exptime, gain_mode, $
                                      onband, wavelength, $
                                      found=found, $
                                      error_msg=error_msg, $
                                      times_found=times_found, $
                                      master_extensions=master_extensions, $
                                      raw_extensions=raw_extensions, $
                                      raw_filenames=raw_filenames, $
                                      coefficients=coefficients, $
                                      sgsdimv=sgsdimv
  compile_opt strictarr

  interpolate = self.run->config('calibration/interpolate_flats')
  self.run->getProperty, logger_name=logger_name

  ; Science data and flats should match number of tunings, i.e., a science
  ; image from a file with 5 wavelength tunings should be corrected with a flat
  ; from a file with 5 tunings. For now, it looks like this will be taken care
  ; of by the recipes: appropriate flats will always be taken after other flats,
  ; but before science images so that when looking backwards in time, the
  ; correct flats will be nearest in time.

  found = 0B
  error_msg = ''
  if (n_elements(*self.flats) eq 0L) then begin
    error_msg = 'no flats'
    return, !null
  endif

  ; find the darks with an exposure time and wavelength that is close enough to
  ; the given exposure time and wavelength
  exptime_threshold    = 0.01      ; [ms]
  wavelength_threshold = 0.001     ; [nm]
  gain_index           = gain_mode eq 'high'
  onband_index         = onband eq 'tcam'
  valid_indices = where((abs(wavelength - *self.flat_wavelengths) lt wavelength_threshold) $
                          and (*self.flat_gain_modes eq gain_index) $
                          and (*self.flat_onbands eq onband_index), $
                          ; TOOD: removing below allows flats in the future to be found
                          ;and (obsday_hours gt *self.flat_times), $
                        n_valid_flats)
  if (n_valid_flats eq 0L) then begin
    error_msg = 'no valid flats'
    return, !null
  endif

  found = 1B

  ; find the closest flat, or two closest flats before and after, if
  ; interpolate is set and there are flats before and after
  valid_flats = (*self.flats)[*, *, *, valid_indices]
  valid_times = (*self.flat_times)[valid_indices]
  if (obsday_hours lt valid_times[0]) then begin
    sgsdimv = (*self.flat_sgsdimv)[valid_indices[0]]
    interpolated_flat = float(valid_flats[*, *, *, 0])

    exptime_found = (*self.flat_exptimes)[valid_indices[0]]
    interpolated_flat *= exptime / exptime_found

    times_found = (*self.flat_times)[valid_indices[0]]
    flat_dark = self->get_dark(times_found, exptime, gain_mode, $
                               found=flat_dark_found, error_msg=dark_error_msg)
    if (~flat_dark_found) then begin
      found = 0B
      error_msg = dark_error_msg
      return, !null
    endif
    interpolated_flat -= flat_dark

    master_extensions = self->convert_flat_index_to_wave_region(valid_indices[0]) + 1L
    raw_extensions = (*self.flat_extensions)[valid_indices[0]]
    raw_filenames = strtrim((*self.flat_raw_files)[valid_indices[0]], 2)
    coefficients = 1.0
  endif else if (obsday_hours gt valid_times[n_valid_flats - 1]) then begin
    sgsdimv = (*self.flat_sgsdimv)[valid_indices[n_valid_flats - 1]]
    interpolated_flat = float(valid_flats[*, *, *, n_valid_flats - 1])

    exptime_found = (*self.flat_exptimes)[valid_indices[n_valid_flats - 1]]

    interpolated_flat *= exptime / exptime_found

    times_found = (*self.flat_times)[valid_indices[n_valid_flats - 1L]]
    flat_dark = self->get_dark(times_found, exptime, gain_mode, $
                               found=flat_dark_found, error_msg=dark_error_msg)
    if (~flat_dark_found) then begin
      found = 0B
      error_msg = dark_error_msg
      return, !null
    endif
    interpolated_flat -= flat_dark

    master_extensions = self->convert_flat_index_to_wave_region(valid_indices[n_valid_flats - 1]) + 1L
    raw_extensions = (*self.flat_extensions)[valid_indices[n_valid_flats - 1]]
    raw_filenames = strtrim((*self.flat_raw_files)[valid_indices[n_valid_flats - 1]], 2)
    coefficients = 1.0
  endif else begin
    if (keyword_set(interpolate)) then begin
      index1 = value_locate(valid_times, obsday_hours)
      index2 = index1 + 1L

      flat1 = valid_flats[*, *, *, index1]
      exptime_found = (*self.flat_exptimes)[valid_indices[index1]]
      flat1 *= exptime / exptime_found

      flat2 = valid_flats[*, *, *, index2]
      exptime_found = (*self.flat_exptimes)[valid_indices[index2]]
      flat2 *= exptime / exptime_found

      times_found = (*self.flat_times)[valid_indices[[index1, index2]]]

      flat_dark1 = self->get_dark(times_found[0], exptime, gain_mode, $
                                  found=flat_dark_found, error_msg=dark_error_msg)
      if (~flat_dark_found) then begin
        found = 0B
        error_msg = dark_error_msg
        return, !null
      endif
      flat1 -= flat_dark1

      flat_dark2 = self->get_dark(times_found[1], exptime, gain_mode, $
                                  found=flat_dark_found, error_msg=dark_error_msg)
      if (~flat_dark_found) then begin
        found = 0B
        error_msg = dark_error_msg
        return, !null
      endif
      flat2 -= flat_dark2

      a1 = (valid_times[index2] - obsday_hours) / (valid_times[index2] - valid_times[index1])
      a2 = (obsday_hours - valid_times[index1]) / (valid_times[index2] - valid_times[index1])
      interpolated_flat = a1 * flat1 + a2 * flat2

      master_extensions = self->convert_flat_index_to_wave_region(valid_indices[[index1, index2]]) + 1L
      raw_extensions = (*self.flat_extensions)[valid_indices[[index1, index2]]]
      raw_filenames = strtrim((*self.flat_raw_files)[valid_indices[[index1, index2]]], 2)

      sgsdimv = a1 * (*self.flat_sgsdimv)[valid_indices[index1]] + a2 * (*self.flat_sgsdimv)[valid_indices[index2]]

      coefficients = [a1, a2]
    endif else begin
      index = value_locate(valid_times, obsday_hours)

      sgsdimv = (*self.flat_sgsdimv)[valid_indices[index]]

      interpolated_flat = valid_flats[*, *, *, index]

      exptime_found = (*self.flat_exptimes)[valid_indices[index]]
      interpolated_flat *= exptime / exptime_found

      times_found = (*self.flat_times)[valid_indices[index]]
      flat_dark = self->get_dark(times_found, exptime, gain_mode, $
                                 found=flat_dark_found, error_msg=dark_error_msg)
      if (~flat_dark_found) then begin
        found = 0B
        error_msg = dark_error_msg
        return, !null
      endif
      interpolated_flat -= flat_dark

      master_extensions = self->convert_flat_index_to_wave_region(valid_indices[index]) + 1L
      raw_extensions = (*self.flat_extensions)[valid_indices[index]]
      raw_filenames = strtrim((*self.flat_raw_files)[valid_indices[index]], 2)
      coefficients = 1.0
    endelse
  endelse

  return, float(reform(interpolated_flat))
end


;+
; Free resources.
;-
pro ucomp_calibration::cleanup
  compile_opt strictarr

  ptr_free, self.darks, self.dark_times, self.dark_exptimes, $
            self.dark_gain_modes, self.dark_raw_files
  ptr_free, self.flats, self.flat_times, self.flat_exptimes, $
            self.flat_wavelengths, self.flat_gain_modes, self.flat_onbands, $
            self.flat_sgsdimv, self.flat_extensions, self.flat_raw_files, $
            self.flat_wave_region_offsets

end


;+
; Initialize the calibration object.
;
; :Returns:
;   1 for success, 0 for failure
;
; :Keywords:
;   run : in, required, type=object
;     UCoMP run object
;-
function ucomp_calibration::init, run=run
  compile_opt strictarr

  self.run = run

  ; master dark cache
  self.darks            = ptr_new(/allocate_heap)
  self.dark_times       = ptr_new(/allocate_heap)
  self.dark_exptimes    = ptr_new(/allocate_heap)
  self.dark_gain_modes  = ptr_new(/allocate_heap)
  self.dark_raw_files   = ptr_new(/allocate_heap)

  ; master flat cache
  self.flats            = ptr_new(/allocate_heap)
  self.flat_times       = ptr_new(/allocate_heap)
  self.flat_exptimes    = ptr_new(/allocate_heap)
  self.flat_wavelengths = ptr_new(/allocate_heap)
  self.flat_gain_modes  = ptr_new(/allocate_heap)
  self.flat_onbands     = ptr_new(/allocate_heap)
  self.flat_sgsdimv     = ptr_new(/allocate_heap)
  self.flat_extensions  = ptr_new(/allocate_heap)
  self.flat_raw_files   = ptr_new(/allocate_heap)
  self.flat_wave_region_offsets = ptr_new(/allocate_heap)
  *self.flat_wave_region_offsets = [0L]

  return, 1
end


;+
; Define the fields of a calibration object.
;-
pro ucomp_calibration__define
  compile_opt strictarr

  !null = {ucomp_calibration, inherits IDL_Object, $
           run : obj_new(), $

           ; master dark cache
           darks: ptr_new(), $
           dark_times: ptr_new(), $
           dark_exptimes: ptr_new(), $
           dark_gain_modes: ptr_new(), $
           dark_raw_files: ptr_new(), $

           ; master flat cache
           flats: ptr_new(), $             ; fltarr(nx, ny, 4, 2, n_flats)
           flat_times: ptr_new(), $        ; obsday hours
           flat_exptimes: ptr_new(), $     ; [ms] exposure time
           flat_wavelengths: ptr_new(), $  ; [nm] wavelengths
           flat_gain_modes: ptr_new(), $   ; 'low' or 'high'
           flat_onbands: ptr_new(), $      ; 'tcam' or 'rcam'
           flat_sgsdimv: ptr_new(), $      ; SGSDIMV values
           flat_extensions: ptr_new(), $   ; extension into flat file
           flat_raw_files: ptr_new(), $    ; basename of raw file containing flat
           flat_wave_region_offsets: ptr_new() $ ; offset

           ; TODO: demodulation matrices
  }
end
