#!/usr/bin/env python

import argparse
import datetime
import os
import psutil
import subprocess


DATE_FORMAT = '%Y%m%d'

DEVNULL = open(os.devnull, 'w')
PIPELINE_DIR = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))


intervals = (
    ('weeks', 604800),  # 60 * 60 * 24 * 7
    ('days', 86400),    # 60 * 60 * 24
    ('hrs', 3600),    # 60 * 60
    ('mins', 60),
    ('secs', 1),
    )

def display_time(seconds, granularity=2):
    result = []

    for name, count in intervals:
        value = seconds // count
        if value:
            seconds -= value * count
            if value == 1:
                name = name.rstrip('s')
            result.append("%d %s" % (value, name))
    return ' '.join(result[:granularity])


def format_timedelta(timedelta):
    return(display_time(int(timedelta.total_seconds()), granularity=len(intervals)))


def list_processes():
    ucomp_processes = []
    for p in psutil.process_iter():
        cmdline = p.cmdline()
        cmdline = '' if len(cmdline) == 0 else cmdline[-1]
        if p.name() == 'idl' and cmdline.startswith('ucomp'):
            ucomp_processes.append({'cmdline': cmdline,
                                    'pid': p.pid,
                                    'start_time': p.create_time()})
    if len(ucomp_processes) == 0:
        print('no UCoMP processes currently running')
        return

    now = datetime.datetime.now()

    for p in ucomp_processes:
        started = datetime.datetime.fromtimestamp(p['start_time'])
        time_running = now - started
        start_time = started.strftime("%Y-%m-%d %H:%M:%S")
        print('[%d] (%s running %s): %s' % (p['pid'],
                                            start_time,
                                            format_timedelta(time_running), p['cmdline']))


def parse_date_expr(date_expr):
    dates = []

    try:
        for de in date_expr.split(','):
            d = de.split('-')
            if len(d) not in [1, 2]:
                print(f'invalid syntax: {de}')
                return []

            if len(d) == 1:
                date_string = d[0]
                date = datetime.datetime.strptime(date_string, DATE_FORMAT)
                dates.append(date.strftime(DATE_FORMAT))

            if len(d) == 2:
                date_string = d[0]
                date = datetime.datetime.strptime(date_string, DATE_FORMAT)
                date_string = d[1]
                end_date = datetime.datetime.strptime(date_string, DATE_FORMAT)
                if date > end_date:
                    print(f'invalid date range {de}')
                    return []
                while date.strftime(DATE_FORMAT) != end_date.strftime(DATE_FORMAT):
                    dates.append(date.strftime(DATE_FORMAT))
                    date = date + datetime.timedelta(days=1)
    except ValueError:
        print(f'invalid date syntax: {date_string}')
        return []

    return dates


def process_realtime(dates, flags, no_wait):
    launch_processes(dates, flags, no_wait, 'ucomp_realtime.sh')


def process_dates(dates, flags, no_wait):
    launch_processes(dates, flags, no_wait, 'ucomp_process.sh')


def launch_processes(dates, flags, no_wait, routine):
    for d in dates:
        cmd = [os.path.join(PIPELINE_DIR,
                            'bin',
                            routine),
               flags,
               d]

        process = subprocess.Popen(cmd, stderr=subprocess.STDOUT)
        print('[%d] %s' % (process.pid, ' '.join(cmd)))
        if not no_wait:
            terminated = wait_for(process)
            if terminated: break


def wait_for(process):
    try:
        process.wait()
        return 0
    except KeyboardInterrupt:
        print('killing process %d' % process.pid)
        process.kill()
        return 1


if __name__ == '__main__':
    name = 'UCoMP pipeline @VERSION@'

    parser = argparse.ArgumentParser(description=name)

    date_help = '''Dates to run on in the form YYYYMMDD including lists (using
                   commas) and ranges (using hyphens). Note that the beginning
                   of a range is inclusive and the end is exclusive. For
                   example, '20170101-20170201' represents all of January 2017,
                   '20170201,20170202' represents the first two days of February
                   2017, and '20170101-20170201,20170201,20170202' represents
                   all of January and the first two days of February 2017.
                '''
    parser.add_argument('dates', type=str, nargs='*', help=date_help)

    parser.add_argument('-l', '--list', action='store_true',
                        help='set to list UCoMP processes')

    parser.add_argument('-f', '--flags',
                        type=str,
                        default='latest',
                        help='''FLAGS section of config filename, i.e., file in
                                config/ directory matching ucomp.user.machine.FLAGS.cfg
                                will be used''')

    parser.add_argument('-r', '--realtime', action='store_true',
                        help='set to run the realtime instead of full processing')
    parser.add_argument('--no-wait',
                        action='store_true',
                        help='set to run all dates simultaneously')

    parser.add_argument('-v', '--version',
                        action='version',
                        version=name)

    args = parser.parse_args()

    if args.list:
        list_processes()
        parser.exit(status=0)

    # only allow no date arguments if doing a listing 
    if len(args.dates) == 0:
        parser.error('too few arguments')

    date_expr = ''.join(args.dates)
    dates = parse_date_expr(date_expr)

    if args.realtime:
        if len(dates) != 1:
            parser.error('realtime mode is only valid for a single date')
            process_realtime(dates, args.flags, args.no_wait)
    else:
        process_dates(dates, args.flags, args.no_wait)
